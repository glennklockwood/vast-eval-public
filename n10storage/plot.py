import math
import warnings

import numpy
import pandas
import matplotlib
import matplotlib.pyplot

from .common import humanize_bytes
from .contention import pivot_to_losses, pivot_and_subselect_workload, CONTENTION_METRIC_NAMES, CONTENTION_METRIC_UNITS

COLORS = [
    (0x1f, 0x77, 0xb4),
    (0xff, 0x7f, 0x0e),
]

VAST_DBOX_NVRAM_BUFFER_TBS = 3.0  # VAST DBox's NVRAM write buffer is 3 TB per Howard Marks
VAST_DBOX_QLC_CAPACITY_TBS = 15.36 * 44 * 36 / 40 # 44x 15.36 TB drives at 36+4

#
# Universal Functions
#
def verify_plot_datasets(datasets, min_walltime=45):
    for dataset_name, dataset in datasets.items():
        under_walltime = ""
        if 'stonewall_time_secs' in dataset:
            under_walltime = " and {:d} results under {:d} seconds".format(
                (dataset['stonewall_time_secs'] < 45).astype(int).sum(),
                min_walltime)
        grouped_df = dataset.groupby(['nodes', 'ppn', 'xfersize', 'access'])
        mode = grouped_df.count()['iter'].mode().values[0]
        filt = (grouped_df.count()['iter'] != mode)
        if sum(filt):
            print(f"{dataset_name} had some incomplete runs (expecting {mode:d}){under_walltime}")
            print(grouped_df.count()[filt]['bw(mib/s)'])
        else:
            print(f"{dataset_name} has {dataset.shape[0]:d} results{under_walltime}")

def plot_all_data(datasets, plot_function, dataset_mapper=None):
    """Plots multiple datasets in the same fashion in a vertical stack.

    Args:
        datasets: Dictionary with {str: pandas.DataFrame} elements.
        plot_function: Function that accepts a pandas.DataFrame and
            matplotlib.Axes as its two arguments.
        dataset_mapper (optional): Apply this function to each value of
            `datasets` and pass its output to plot_function instead of
            passing each `datasets` value directly.  Must return a
            pandas.DataFrame.
        """
    last_fig = len(datasets) - 1
    fig, axes = matplotlib.pyplot.subplots(
        len(datasets), 1, 
        sharex=True,
        sharey=True,
        squeeze=False,
        figsize=(6, 8.0 / 3.0 * (last_fig + 1)))
    axes = axes.flatten()
    fig.subplots_adjust(hspace=0)
    for (idx, (dataset, results)) in enumerate(datasets.items()):
        ax = axes[idx]
        if dataset_mapper:
            plot_function(dataset_mapper(results), ax=ax)
        else:
            plot_function(results, ax=ax)

        if ax.get_title():
            ax.text(0.5, 0.9, "{} ({})".format(dataset, ax.get_title()), transform=ax.transAxes, ha='center')
        else:
            ax.text(0.5, 0.9, "{}".format(dataset), transform=ax.transAxes, ha='center')
        ax.set_title("")

        if idx < last_fig:
            ax.set_ylabel("")
            ax.set_xlabel("")
        if idx != 0 and ax.get_legend():
            ax.get_legend().remove()

    ax.text(0, 0.5, ax.get_ylabel(), transform=fig.transFigure, va='center', rotation=90)
    ax.set_ylabel("")
    if ax.get_xlim()[-1] > 1000:
        for tick in ax.get_xticklabels():
            tick.set_rotation(45)
            tick.set_ha('right')
    return axes

def summarize_max_results(all_results):
    """Returns dataframe summarizing the maximum performance for each IOR run

    Args:
        all_results (pandas.DataFrame): Dataframe generated by load_output_files()

    Returns:
        pandas.DataFrame
    """
    # Create a new representation of the results containing the max read and write per file
    GROUP_KEYS = ['filename', 'nodes', 'ppn', 'xfersize', 'nproc']
    MAX_INDICES = all_results.groupby(GROUP_KEYS + ['access'])['bw(mib/s)'].idxmax()
    COLNAME_MAP = {'read': 'max_read_mibs', 'write': 'max_write_mibs'}

    # pivot the dataframe, preserve index, then re-add reduced columns
    _tmp_df = all_results.loc[MAX_INDICES].pivot(columns='access', values='bw(mib/s)')
    _tmp_df.columns = [COLNAME_MAP.get(x, x) for x in _tmp_df.columns]
    _tmp_df = pandas.concat((all_results, _tmp_df), axis='columns').groupby(['filename']).max()[['max_read_mibs', 'max_write_mibs']]

    return pandas.merge(
        all_results[GROUP_KEYS].set_index('filename').drop_duplicates(),
        _tmp_df,
        left_index=True, right_index=True).sort_index()

def gradient_colormap(color, idx, out_of=4):
    return tuple([(idx + 1) * x / out_of / 0xff for x in color])

# Plot-specific Functions
def plot_allbw_vs_nproc_boxplot(all_results, keys=None, norm=False, ax=None):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    grouped_results = all_results[['nproc', 'access', 'bw(mib/s)']].groupby('nproc')

    # keys = list of unique nproc values
    # values = list of dataframes (not groupby objects) corresponding to keys
    _keys, values = zip(*grouped_results)

    if keys is not None:
        _keys = keys

    norm_by = 1024.0
    if norm:
        norm_by = all_results['bw(mib/s)'].max()

    for access in 'read', 'write':
        if keys is None:
            xvals = [x[x['access'] == access]['bw(mib/s)'] / norm_by for x in values]
        else:
            xvals = []
            for key in keys:
                try:
                    x = grouped_results.get_group(key)
                except KeyError:
                    x = None
                if x is None:
                    xvals.append([])
                else:
                    xvals.append(x[x['access'] == access]['bw(mib/s)'] / norm_by)

        boxplot = ax.boxplot(
            xvals,
            widths=0.35,
            positions=numpy.arange(1, len(_keys)+1) + (-0.2 if access == 'read' else +0.2),
            patch_artist=True,
            medianprops={"color": "black"},
        )
        for face in boxplot['boxes']:
            face.set_facecolor('C0' if access == 'read' else 'C1')
            face.set_alpha(0.75)

    legend_elements = [
        matplotlib.patches.Patch(facecolor='C0', alpha=0.75, label='Read'),
        matplotlib.patches.Patch(facecolor='C1', alpha=0.75, label='Write'),
    ]
    ax.legend(handles=legend_elements,
              bbox_to_anchor=(0.0, 1.02, 1.0, .102),
              loc='lower left',
              ncol=2,
              mode="expand",
              borderaxespad=0.0,
              fontsize="smaller")
    ax.set_xlabel("Num Processes")
    if norm:
        ax.set_ylabel("Fraction Peak Bandwidth")
        ax.set_ylim(0.0, 1.15)
    else:
        ax.set_ylabel("Bandwidth (GiB/s)")
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(1 + numpy.arange(0, len(_keys))))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(_keys))
    ax.yaxis.grid()
    ax.set_axisbelow(True)
    return ax

def plot_allbw_vs_nproc_by_xsize(all_results, norm=False, ax=None, fill=False):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    norm_by = 1024.0
    if norm:
        norm_by = all_results['bw(mib/s)'].max()

    plotted_legend = {}

    for access, subset_df in all_results.groupby('access'):
        last_y = None
        for xfersize, subset_df_2 in subset_df.groupby('xfersize'):
            xvals = []
            yvals = []
            for nproc, bw in subset_df_2.groupby('nproc'):
                xvals.append(nproc)
                yvals.append(bw['bw(mib/s)'].mean() / norm_by)
            plot_args = {
                "color": 'C0' if access == 'read' else 'C1',
                "linewidth": xfersize / 32 / 2**20 * 5 + 1,
                "alpha": 0.750
            }
            if access not in plotted_legend:
                plot_args['label'] = access.title()
                plotted_legend[access] = True
            ax.plot(xvals, yvals, **plot_args)
            if fill:
                if last_y is not None:
                    ax.fill_between(
                        xvals,
                        yvals,
                        last_y,
                        color='C0' if access == 'read' else 'C1',
                        alpha=0.50,
                    )
                last_y = yvals
    ax.set_xlabel("Num Processes")
    try:
        ax.set_xscale("log", base=2)
    except ValueError:
        ax.set_xscale("log", basex=2)
    if norm:
        ax.set_ylabel("Fraction Peak Bandwidth")
        ax.set_ylim(0.0, 1.15)
    else:
        ax.set_ylabel("Bandwidth (GiB/s)")

    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(sorted(all_results['nproc'].unique())))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FormatStrFormatter("%.0f"))
    ax.grid()
    ax.legend(
              bbox_to_anchor=(0.0, 1.02, 1.0, .102),
              loc='lower left',
              ncol=2,
              mode="expand",
              borderaxespad=0.0,
              fontsize="smaller")
    ax.set_axisbelow(True)

def plot_bw_vs_xfersize_boxplot(all_results, ax=None, filt=None):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()
    keys, values = zip(*all_results.groupby('xfersize'))
    keys = ["{:.0f} {}".format(*humanize_bytes(x)) for x in keys]

    legend_elements = []
    for access, color in [('read', 'C0'), ('write', 'C1')]:
        if filt:
            xvals = [x[(x['access'] == access) & (filt(x))]['bw(mib/s)'] / 1024 for x in values]
        else:
            xvals = [x[x['access'] == access]['bw(mib/s)'] / 1024 for x in values]

        bp1 = ax.boxplot(
            xvals,
            widths=0.35,
            positions=numpy.arange(1, len(keys)+1) + (-0.2 if access == 'read' else +0.2),
            patch_artist=True,
            boxprops={'edgecolor': color},
            whiskerprops={'color': color},
            capprops={'color': color},
            flierprops={'markeredgecolor': color},
            medianprops={'color': color}
        )
        for face in bp1['boxes']:
            face.set_facecolor(color)
            face.set_alpha(0.5)

        if filt:
            xvals = [x[(x['access'] == 'write') & (filt(x))]['bw(mib/s)'] / 1024 for x in values]
        else:
            xvals = [x[x['access'] == 'write']['bw(mib/s)'] / 1024 for x in values]

        legend_elements.append(matplotlib.patches.Patch(facecolor=color, alpha=0.5, label=access.title()))

    ax.legend(handles=legend_elements,
              bbox_to_anchor=(0.0, 1.02, 1.0, .102),
              loc='lower left',
              ncol=2,
              mode="expand",
              borderaxespad=0.0,
              fontsize="smaller")
    ax.set_xlabel("Transfer Size")
    ax.set_ylabel("Bandwidth (GiB/s)")
    ax.set_xticklabels(ax.get_xticks(), rotation=30, ha='right')
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(1 + numpy.arange(0, len(keys))))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(keys))
    ax.yaxis.grid()
    ax.set_axisbelow(True)

    return ax

def plot_alliops_vs_nproc_boxplot(all_results, keys=None, ax=None):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    grouped_results = all_results[['nproc', 'access', 'iops']].groupby('nproc')

    # keys = list of unique nproc values
    # values = list of dataframes (not groupby objects) corresponding to keys
    _keys, values = zip(*grouped_results)

    if keys is not None:
        _keys = keys

    for cidx, access in enumerate(['read', 'write']):
        if keys is None:
            xvals = [x[x['access'] == access]['iops'] / 1000 for x in values]
        else:
            xvals = []
            for key in keys:
                try:
                    x = grouped_results.get_group(key)
                except KeyError:
                    x = None
                if x is None:
                    xvals.append([])
                else:
                    xvals.append(x[x['access'] == access]['iops'] / 1000)

        color = "C{:d}".format(cidx)
        boxplot = ax.boxplot(
            xvals,
            widths=0.35,
            positions=numpy.arange(1, len(_keys)+1) + (-0.2 if access == 'read' else +0.2),
            patch_artist=True,
            boxprops={'edgecolor': color},
            whiskerprops={'color': color},
            capprops={'color': color},
            flierprops={'markeredgecolor': color},
            medianprops={'color': color}
        )
        for face in boxplot['boxes']:
            face.set_facecolor('C0' if access == 'write' else 'C1')
            face.set_alpha(0.75)

    legend_elements = [
        matplotlib.patches.Patch(facecolor='C0', alpha=0.75, label='Write'),
        matplotlib.patches.Patch(facecolor='C1', alpha=0.75, label='Read'),
    ]
    ax.legend(handles=legend_elements,
              bbox_to_anchor=(0.0, 1.02, 1.0, .102),
              loc='lower left',
              ncol=2,
              mode="expand",
              borderaxespad=0.0,
              fontsize="smaller")
    ax.set_xlabel("Num Processes")
    ax.set_ylabel("kIOPS")
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(1 + numpy.arange(0, len(_keys))))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(_keys))
    ax.yaxis.grid()
    ax.set_axisbelow(True)

    return ax

def plot_alliops_vs_nproc_bynode(all_results, ax=None):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    for cidx, rw in enumerate(['read', 'write']):
        plot_df = all_results[all_results['access'] == rw]
        max_nodes = math.log2(plot_df['nodes'].max())
        for nodect, grouped_plot_df in plot_df.groupby('nodes'):
            iops_by_nodect = grouped_plot_df.groupby('nproc')['iops']
            y = iops_by_nodect.mean() / 1000
            x = y.index
            ystd = iops_by_nodect.std() / 1000
                        
            color = gradient_colormap(COLORS[cidx], math.log2(nodect))
            linestyle = dict(
                marker='o',
                markersize=nodect,
                linewidth=max(1, math.log2(nodect)),
                linestyle='--' if math.log2(nodect) < 1 else "-",
                label="{:d} node{}, {}".format(nodect, "s" if nodect != 1 else "", rw),
                alpha=0.75,
            )
            otherstyle = dict(
                color=color, #'C{:d}'.format(cidx))
                zorder=10 * (1 + max_nodes - math.log2(nodect))
            )
            style = linestyle.copy()
            style.update(otherstyle)
            ax.plot(x, y, **style)
            ax.errorbar(x, y, yerr=ystd, linestyle="none", alpha=0.50, capsize=4.0, **otherstyle)
    ax.set_xlabel("Num Processes")
    try:
        ax.set_xscale("log", base=2)
    except ValueError:
        ax.set_xscale("log", basex=2)
    ax.set_ylabel("kIOPS")
    ax.legend(bbox_to_anchor=(0.0, 1.02, 1.0, .102),
              loc='lower left',
              ncol=2,
              mode="expand",
              borderaxespad=0.0,
              fontsize="smaller",
              labelspacing=0)
    ax.grid()
    ax.set_axisbelow(True)
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(all_results['nproc'].unique()))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FormatStrFormatter("%.0f"))
    return ax

def calculate_fraction_peak_bw(all_results):
    variations = []
    for access in 'read', 'write':
        try:
            access_group = all_results\
                .groupby('access').get_group(access)\
                .groupby('xfersize') # dataframe of read or write data
        except KeyError:
            continue
        max_bw = access_group['bw(mib/s)'].mean().max()
        variation_ser = access_group.mean()['bw(mib/s)'] / max_bw
        variation_ser.name = access
        variations.append(variation_ser)
    return pandas.concat(variations, axis=1)

def plot_fraction_peak_bw(all_results, ax=None):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    variation_df = calculate_fraction_peak_bw(all_results)
    variation_df.plot.bar(width=0.85, ax=ax)
    ax.set_xticklabels(["{:.0f} {}".format(*humanize_bytes(float(x.get_text()))) for x in ax.get_xticklabels()], ha='right', rotation=30)
    ax.set_axisbelow(True)
    ax.yaxis.grid(True)
    ax.set_xlabel("Transfer Size")
    ax.set_ylabel("Fraction of Peak Bandwidth")
    #ax.set_title("{}, {:d} node{}".format(key, TARGET_NODES, "" if TARGET_NODES == 1 else "s"))
    ax.legend(ncol=2, loc='lower right')
    return ax

def plot_compare_rw_bw_vs_nproc(all_datasets, norm=False, access=None, ax=None):
    """Plots comparison of the read and write bandwidth vs nproc for each
    dataset and access mode.

    Args:
        all_datasets (dict): values are full dataframes as returned by
            load_ior_output_files().  Each value contained will be plotted
            as two lines--one for reads, one for writes.
    """
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()
    if access is None:
        access = ["read", "write"]
    elif isinstance(access, str):
        if access[0].lower() == 'r':
            access = ['read']
        elif access[0].lower() == 'w':
            access = ['write']
        else:
            raise ValueError(f"Unsupported access type {access}")

    norm_by = 1024.0
    for idx, (key, dataset) in enumerate(all_datasets.items()):
        if norm:
            norm_by = dataset['bw(mib/s)'].max()

        for jdx, jaccess in enumerate(access):
            color = 'C{:d}'.format((jdx if len(access) > 1 else idx) + 1)
            series = dataset.groupby('access').get_group(jaccess).groupby('nproc')['bw(mib/s)']
            ymean = series.mean() / norm_by
            yerr = series.std() / norm_by
            ax.errorbar(
                x=ymean.index,
                y=ymean.values,
                yerr=yerr.reindex(index=ymean.index),
                color=color,
                capsize=4.0,
                marker='o',
                markerfacecolor="None" if idx == 0 else color,
                markeredgecolor=color,
                linestyle="--" if idx == 0 else "-",
                label="{} {}".format(key, jaccess) if len(access) > 1 else key,
            )

    ax.set_axisbelow(True)
    ax.grid()
    ax.set_xlabel("Num Processes")
    if norm:
        ax.set_ylabel("Fraction Peak Bandwidth")
        ax.set_ylim(0.0, 1.15)
    else:
        ax.set_ylabel("Mean Bandwidth (GiB/s)")

    try:
        ax.set_xscale("log", base=2)
    except ValueError:
        ax.set_xscale("log", basex=2)
    ax.xaxis.set_major_locator(matplotlib.ticker.LogLocator(base=2.0, numticks=1+ymean.index.unique().shape[0]))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FormatStrFormatter("%.0f"))
    if not norm:
        ax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(steps=[1, 2, 5], integer=True))
    ax.legend()
    return ax

def plot_alliops_vs_nproc_boxplots_by_nodect(all_results, ax=None):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    full_column_width = 1.0
    column_width = full_column_width * 0.90
    cols = numpy.sort(all_results['nproc'].unique())
    num_cols = cols.shape[0]
    boxes_per_col = all_results['nodes'].unique().shape[0]
    box_width = column_width / boxes_per_col
    base_positions = numpy.arange(1, num_cols + 1)

    legend_elements = []
    for cidx, access in enumerate(['read', 'write']):
        plot_df = all_results[all_results['access'] == access]
        for bidx, (nodect, grouped_plot_df) in enumerate(plot_df.groupby('nodes')):
            iops_by_nodect = grouped_plot_df.groupby('nproc')
            y = []
            ymedian = []
            for col in cols:
                try:
                    y.append(iops_by_nodect.get_group(col)['iops'] / 1000)
                    ymedian.append(numpy.median(y[-1]))
                except KeyError:
                    y.append([])
                    ymedian.append(None)

            x = base_positions - (full_column_width / 2 + box_width / 4) + ((1 + bidx) * box_width)
            color = gradient_colormap(COLORS[cidx], math.log2(nodect))
            bp = ax.boxplot(
                y,
                widths=box_width * 1,
                positions=x,
                patch_artist=True,
                boxprops={'edgecolor': color},
                whiskerprops={'color': color},
                capprops={'color': color},
                flierprops={'markeredgecolor': color},
                medianprops={'color': color},
                showfliers=False,
            )
            ax.plot(
                x,
                ymedian,
                marker='o',
                markersize=4,
                markeredgecolor=color,
#                 markerfacecolor="none",
                alpha=0.75,
                linestyle="none")
            for face in bp['boxes']:
                face.set_facecolor(color)
                face.set_alpha(0.75)
            legend_elements.append(matplotlib.patches.Patch(
                facecolor=color,
                alpha=0.75,
                label="{:d} client{}, {}".format(nodect, "s" if nodect != 1 else "", access)))

    ax.set_xlabel("Num Processes")
    ax.set_ylabel("kIOPS")
    ax.set_xlim(full_column_width / 2, num_cols + full_column_width / 2)
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(base_positions))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(cols))
    ax.xaxis.set_minor_locator(matplotlib.ticker.FixedLocator(base_positions[1:] - full_column_width / 2.0))
    ax.xaxis.grid(which="minor")

#     ax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=7, integer=True))
#     ax.yaxis.set_minor_locator(matplotlib.ticker.MaxNLocator(nbins=14, integer=True))
#     ax.yaxis.grid(which="minor")

    ax.legend(handles=legend_elements,
              bbox_to_anchor=(0.0, 1.02, 1.0, .102),
              loc='lower left',
              ncol=2,
              mode="expand",
              borderaxespad=0.0,
              labelspacing=0,
              fontsize="smaller")
    ax.set_axisbelow(True)
    return ax

def plot_alliops_vs_nproc_errorbar_by_nodect(all_results, ax=None):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    full_column_width = 1.0
    column_width = full_column_width * 0.90
    cols = numpy.sort(all_results['nproc'].unique())
    num_cols = cols.shape[0]
    boxes_per_col = all_results['nodes'].unique().shape[0]
    box_width = column_width / boxes_per_col
    base_positions = numpy.arange(1, num_cols + 1)
    markers = ['.', '+', 'v', '^']

    legend_elements = []
    for cidx, access in enumerate(['read', 'write']):
        plot_df = all_results[all_results['access'] == access]
        for bidx, (nodect, grouped_plot_df) in enumerate(plot_df.groupby('nodes')):
            plot_data = []
            iops_by_nodect = grouped_plot_df.groupby('nproc')
            for colidx, col in enumerate(cols):
                x = colidx + 1 - (full_column_width / 2 + box_width / 4) + ((1 + bidx) * box_width)
                try:
                    plot_data.append({
                        "x": x,
                        "y": numpy.median(iops_by_nodect.get_group(col)['iops'] / 1000),
                        "yerr": numpy.std(iops_by_nodect.get_group(col)['iops'] / 1000),
                    })
                except KeyError:
                    continue

            color = gradient_colormap(COLORS[cidx], math.log2(nodect))
            style = dict(
                color=color,
                marker=markers[bidx % len(markers)],
                markersize=7,
                linestyle="none",
                mfc="none",
            )
            ax.errorbar(
                x=[x['x'] for x in plot_data],
                y=[x['y'] for x in plot_data],
                yerr=[x['yerr'] for x in plot_data],
                mec=color,
                ecolor=color,
                capsize=4,
                **style)
            legend_elements.append(
                matplotlib.lines.Line2D(
                    (0, 0), (1, 1),
                    label="{:d} client{}, {}".format(nodect, "s" if nodect != 1 else "", access),
                    **style,
                )
            )
    ax.set_xlabel("Num Processes")
    ax.set_ylabel("kIOPS")
    ax.set_xlim(full_column_width / 2, num_cols + full_column_width / 2)
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(base_positions))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(cols))
    ax.xaxis.set_minor_locator(matplotlib.ticker.FixedLocator(base_positions[1:] - full_column_width / 2.0))
    ax.xaxis.grid(which="minor")

    ax.legend(handles=legend_elements,
              bbox_to_anchor=(0.0, 1.02, 1.0, .102),
              loc='lower left',
              ncol=2,
              mode="expand",
              borderaxespad=0.0,
              labelspacing=0,
              fontsize="smaller")
    ax.set_axisbelow(True)
    return ax

def plot_read_bw_vs_setsize(all_results, *args, **kwargs):
    default_args = {
        "perf_key": "b",
        "access": "r",
    }
    default_args.update(kwargs)
    return plot_perf_vs_setsize(all_results, *args, **default_args)

def plot_read_iops_vs_setsize(all_results, *args, **kwargs):
    default_args = {
        "perf_key": "i",
        "access": "r",
    }
    default_args.update(kwargs)
    return plot_perf_vs_setsize(all_results, *args, **kwargs)

def plot_perf_vs_setsize(all_results, perf_key, access, relativex=False, norm_y_by=None, norm_x_by=None, ax=None):
    """Plots performance vs. working set size.
    
    Quirks:
      - hard-coded NVRAM write buffer size of 3000 GiB
    
    Args:
        all_results (pandas.DataFrame): Dataframe generated by load_ior_vs_setsize_results()
        perf_key (str): Either "iops" or "bw(mib/s)"
        access (str): Either "read" or "write"
        relativex (bool): When True, plot x relative to NVRAM write buffer size
        norm_y_by (float): Divide all performance measurements (y) by this
            value.  Default is 1000 if perf_key is IOPS and 1024 for bw.
        norm_x_by (float): Divide all set sizes (x) by this value.  Default is
            3000.0 if relativex or 1.0 otherwise.
    """
    if perf_key[0] in ("i", "I"):
        perf_key = "iops"
    elif perf_key[0] in ("b", "B"):
        perf_key = "bw(mib/s)"
    else:
        raise ValueError(perf_key)
        
    if access[0] in ("r", "R"):
        access = "read"
    elif access[0] in ("w", "W"):
        access = "write"
    else:
        raise ValueError(access)
        
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    perf_unit = "unknown"
    if norm_y_by is None:
        if perf_key == "iops":
            norm_y_by = 1000.0
            perf_unit = "KIOPS"
        else:
            norm_y_by = 1024.0
            perf_unit = "GiB/s"
        
    filt = all_results['access'] == access
    dataset = all_results[filt]
    
    nodect = dataset['nodes'].unique()
    assert nodect.shape[0] == 1
    nodect = nodect[0]

    xlabel = None
    if norm_x_by is None:
        xlabel = "Working Set Size (GiB)"
        if relativex:
            norm_x_by = VAST_DBOX_NVRAM_BUFFER_TBS * 1000
            xlabel = "Working Set Size / NVRAM Buffer Size"
        else:
            norm_x_by = 1.0
    
    grouped_dataset = dataset.groupby("setsize_gib_int")[perf_key]

    y = grouped_dataset.mean().sort_index() / norm_y_by
    x = y.index / norm_x_by
    yerr = grouped_dataset.std().sort_index() / norm_y_by
    
    ax.errorbar(
        x=x,
        y=y,
        yerr=yerr,
        marker='.',
        capsize=4.0)
    if xlabel:
        ax.set_xlabel(xlabel)
    if norm_x_by == 1.0:
        ax.set_xscale("log", base=2)
        ax.xaxis.set_major_locator(matplotlib.ticker.LogLocator(base=2.0, numticks=1+x.unique().shape[0]))
        ax.xaxis.set_major_formatter(matplotlib.ticker.FormatStrFormatter("%.0f"))
    else:
        ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(steps=[1, 2, 5, 10], integer=True))

    ax.set_ylabel("{} Rate ({})".format(access.title(), perf_unit))
    ax.set_ylim(0, None)
    ax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(steps=[1, 2, 2.5, 4, 5, 10], integer=True))
    ax.yaxis.set_minor_locator(matplotlib.ticker.MaxNLocator(steps=[1, 1.25, 2, 2.5, 4, 5, 10], integer=True))

    ax.grid()
    ax.set_axisbelow(True)
    return ax

def plot_contention_losses_boxplot(dataframe, workload, workload_col="workload", color=None, relative=True, ax=None, *args, **kwargs):
    """Generates boxplots comparing contention losses of competing workloads
    
    Args:
        dataframe (pandas.DataFrame): output of load_contention_datasets()
        workload (str): One of the values from dataframe's "workload" column to
            subselect.  If workload_col == "workload_id", workload may be
            "primary" or "secondary"
        workload_col (str or list): Column(s) on which boxplots should be
            separated.  The workload arg above is searched in the last of these
            columns.  Typically "workload", ["access", "metric"], or
            "workload_id"
        color (str): Color code to paint boxes.  Used when calling this multiple
            times on the same ax.
        relative (bool): Plot relative loss or absolute loss.
    
    """
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    perf_key = "loss"
    if relative:
        perf_key = "loss%"

    # define styling of boxes
    props = {}
    boxprops = {
        "edgecolor": "black",
        "alpha": 0.50
    }
    flierprops = {}
    if color:
        props.update({"color": color})
        boxprops.update({"facecolor": color})
        flierprops.update({"markeredgecolor": color})
        
    boxplot_options = {
        "boxprops": boxprops,
        "whiskerprops": props,
        "flierprops": flierprops,
        "capprops": props,
        "medianprops": props,
    }
    boxplot_options.update(kwargs)

    # subselect workload to be binned and plotted
    plot_series = pivot_and_subselect_workload(
        dataframe=dataframe,
        workload=workload,
        workload_col=workload_col,
        perf_key=perf_key)
    
    # create dataset to be fed into boxplot - array of arrays
    box_data = {}
    for row in plot_series.itertuples():
        if row[1] not in box_data:      # row[1] = primary_nodes
            box_data[row[1]] = []
        box_data[row[1]].append(row[2]) # row[2] = loss% or loss value
    box_labels = sorted(box_data.keys())

    # create actual boxplot
    boxp = ax.boxplot(
        [box_data[x] for x in box_labels],
        patch_artist=True,
        labels=box_labels,
        *args,
        **boxplot_options,
    )

    ax.xaxis.grid(False)
    ax.yaxis.grid(True)
    ax.set_axisbelow(True)
    ax.set_xlabel("# Primary Workload Nodes ({:d} total)".format(dataframe["primary_nodes"].max() + 1))
    
    filt = dataframe[workload_col] == workload
    access = dataframe[filt]['access'].unique()
    metric = dataframe[filt]['metric'].unique()
    if access.shape[0] != 1 or metric.shape[0] != 1:
        warnings.warn("got multiple accesses and/or metrics")

    if relative:
        ax.set_ylabel("Fraction {}\n{} Lost".format(
            access[0].title(),
            CONTENTION_METRIC_NAMES.get(metric[0], metric[0]).title()))
    else:
        ax.set_ylabel("{} {}\nLost ({})".format(
            access[0].title(),
            CONTENTION_METRIC_NAMES.get(metric[0], metric[0]).title(),
            CONTENTION_METRIC_UNITS.get(metric[0], "?")))
    ax.set_title(None)
    return boxp

def plot_contention_losses_scatter(dataframe, workload, workload_col="workload", color=None, relative=True, ax=None, *args, **kwargs):
    """Generates scatter plot comparing contention losses of competing workloads
    
    Args:
        dataframe (pandas.DataFrame): output of load_contention_datasets()
        workload (str): One of the values from dataframe's "workload" column to
            subselect.  If workload_col == "workload_id", workload may be
            "primary" or "secondary"
        workload_col (str or list): Column(s) on which boxplots should be
            separated.  The workload arg above is searched in the last of these
            columns.  Typically "workload", ["access", "metric"], or
            "workload_id"
        color (str): Color code to paint boxes.  Used when calling this multiple
            times on the same ax.
        relative (bool): Plot relative loss or absolute loss.
    
    """
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

        
    default_args = {
        "capsize": 4.0,
        "marker": "o",
        "linestyle": "none",
    }
    
    perf_key = "loss"
    if relative:
        perf_key = "loss%"
        
    # subselect workload to be binned and plotted
    plot_series = pivot_and_subselect_workload(
        dataframe=dataframe,
        workload=workload,
        workload_col=workload_col,
        perf_key=perf_key)
        
    # create dataset to be fed into boxplot - array of arrays
    yval = plot_series.groupby("primary_nodes").mean()[perf_key]
    yerr = plot_series.groupby("primary_nodes").std()[perf_key]

    errorbar_args = {
        "x": yval.index,
        "y": yval,
        "yerr": yerr,
        "color": color,
        "markeredgecolor": color,
        "markerfacecolor": color,
    }
    errorbar_args.update(default_args)
    errorbar_args.update(**kwargs)
    # create actual boxplot
    ax.errorbar(**errorbar_args)

    ax.xaxis.grid(False)
    ax.yaxis.grid(True)
    ax.set_axisbelow(True)
    idxmax = dataframe["primary_nodes"].idxmax()
    ax.set_xlabel("# Primary Workload Nodes ({:d} total)".format(
        dataframe.loc[idxmax][['primary_nodes', 'secondary_nodes']].sum()))
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(yval.index))
    
    filt = dataframe[workload_col] == workload
    access = dataframe[filt]['access'].unique()
    metric = dataframe[filt]['metric'].unique()
    if access.shape[0] != 1 or metric.shape[0] != 1:
        warnings.warn("got multiple accesses and/or metrics")

    if relative:
        ax.set_ylabel("Fraction {}\n{} Lost".format(
            access[0].title(),
            CONTENTION_METRIC_NAMES.get(metric[0], metric[0]).title()))
    else:
        ax.set_ylabel("{} {}\nLost ({})".format(
            access[0].title(),
            CONTENTION_METRIC_NAMES.get(metric[0], metric[0]).title(),
            CONTENTION_METRIC_UNITS.get(metric[0], "?")))
    ax.set_title(None)

    return ax

def plot_contention_losses_comparison_boxplot(datasets, workload_col, *args, **kwargs):
    default_args = {
        "workload_col": workload_col,
        "relative": True,
    }
    default_args.update(kwargs)
    
    unique_workloads = set()
    for dataset in datasets.values():
        for workload in dataset[workload_col].unique():
            unique_workloads.add(workload)
    unique_workloads = sorted(list(unique_workloads))

    fig, axes = matplotlib.pyplot.subplots(
        len(unique_workloads), 1,
        figsize=(6, 3 * len(unique_workloads)),
        sharex=True)

    fig.subplots_adjust(hspace=0)

    patches = []
    for idx, workload in enumerate(unique_workloads):
        ax = axes[idx]
        for jdx, (dataset_name, dataframe) in enumerate(datasets.items()):
            extra_args = {
                "workload": workload,
                "color": "C{:d}".format(jdx),
                "ax": ax,
            }
            extra_args.update(default_args)

            # draw boxplot
            boxp = plot_contention_losses_boxplot(
                dataframe,
                *args,
                **extra_args)
            if not boxp:
                continue

            # create legend entry for series of boxes
            if idx == 0:
                patches.append(matplotlib.patches.Patch(
                    label=dataset_name,
                    facecolor=boxp['boxes'][0].get_facecolor(),
                    edgecolor=boxp['boxes'][0].get_edgecolor()))

        # fix y range
        if extra_args.get('relative'):
            ax.set_ylabel(workload.title())
            ax.set_ylabel(workload)
            ax.set_ylim(-0.1, 1.1)
            ax.yaxis.set_major_locator(
                matplotlib.ticker.MaxNLocator(nbins=10, steps=[1, 2, 5, 10]))
            ax.yaxis.set_minor_locator(
                matplotlib.ticker.FixedLocator(numpy.arange(0, 1, 0.1)))
        else:
            warnings.warn("relative=False can result in different metrics plotted on same y axis")

        if workload == unique_workloads[-1]:
            ax.xaxis.set_visible(True)
        else:
            ax.xaxis.set_visible(False)

    axes[0].legend(
        handles=patches,
        fontsize=12,
        ncol=2,
        bbox_to_anchor=(0.0, 1.02, 1.0, .102),
        loc='lower left',
        mode="expand",
        borderaxespad=0.0,
    )
    
    return axes

def plot_contention_losses_comparison_scatter(datasets, workload_col, styleconfigs=None, *args, **kwargs):
    default_args = {
        "workload_col": workload_col,
        "relative": True,
    }
    default_args.update(kwargs)
    
    unique_workloads = set()
    for dataset in datasets.values():
        for workload in dataset[workload_col].unique():
            unique_workloads.add(workload)
    unique_workloads = sorted(list(unique_workloads))

    fig, axes = matplotlib.pyplot.subplots(
        len(unique_workloads), 1,
        figsize=(6, 3 * len(unique_workloads)),
        sharex=True)

    fig.subplots_adjust(hspace=0)

    legend_handles = []
    for idx, workload in enumerate(unique_workloads):
        ax = axes[idx]
        for jdx, (dataset_name, dataframe) in enumerate(datasets.items()):
            extra_args = {
                "workload": workload,
                "color": "C{:d}".format(jdx),
                "ax": ax,
            }
            extra_args.update(default_args)
            if styleconfigs:
                extra_args.update(styleconfigs.get(dataset_name, {}))

            # draw boxplot
            ax = plot_contention_losses_scatter(
                dataframe,
                *args,
                **extra_args)

            # create legend entry for series of boxes
            if idx == 0:
                legend_args = {
                    "marker": "o",
                }
                EXCLUDE_STYLE_KEY = ["ax", "workload", "workload_col", "relative", "capsize"]
                for style_key, style_val in extra_args.items():
                    if style_key not in EXCLUDE_STYLE_KEY:
                        legend_args[style_key] = style_val
                legend_handles.append(matplotlib.lines.Line2D(
                    xdata=[0, 0],
                    ydata=[1, 1],
                    label=dataset_name,
                    **legend_args))

        # fix y range
        ax.set_ylabel(workload.title())
        if extra_args.get('relative'):
            ax.set_ylim(-0.1, 1.1)
            ax.yaxis.set_major_locator(
                matplotlib.ticker.MaxNLocator(nbins=10, steps=[1, 2, 5, 10]))
            ax.yaxis.set_minor_locator(
                matplotlib.ticker.FixedLocator(numpy.arange(0, 1, 0.1)))
        else:
            warnings.warn("relative=False can result in different metrics plotted on same y axis")

        if workload == unique_workloads[-1]:
            ax.xaxis.set_visible(True)
        else:
            ax.xaxis.set_visible(False)

    axes[0].text(
        -0.03, 0.50,
        'Fraction Performance Lost',
        transform=fig.transFigure,
        va='center',
        rotation=90)
    for ax in axes:
        ax.set_ylabel(ax.get_ylabel(), fontsize='smaller')
    axes[0].legend(
        handles=legend_handles,
        fontsize=12,
        ncol=2,
        bbox_to_anchor=(0.0, 1.02, 1.0, .102),
        loc='lower left',
        mode="expand",
        borderaxespad=0.0,
    )
    
    return axes

def plot_bw_cv_vs_nproc_bars(all_results, norm=False, ax=None, fill=False):
    if ax is None:
        _, ax = matplotlib.pyplot.subplots()

    X_FIELD = 'nproc'
    BAR_WIDTH = 0.45
    COLORMAP = [
        "#4786B9",
        "#FD8D3B",
    ]

    legend_handles = []
    ax2 = ax.twinx()
    by_access = all_results.groupby(['access'])
    for aidx, access in enumerate(['write', 'read']):
        plot_df = by_access.get_group(access)[[X_FIELD, 'bw(mib/s)']].groupby(X_FIELD)
        cv = plot_df.std()
        plot_df = plot_df.mean()
        cv /= plot_df
        xvals = numpy.arange(plot_df.index.shape[0])
        params = dict(
            color=COLORMAP[aidx],
        )
        ax.bar(
            x=xvals - BAR_WIDTH * aidx,
            height=(plot_df / 1024.0)['bw(mib/s)'].values,
            width=BAR_WIDTH,
            align='edge',
            **params
        )
        legend_handles.append(matplotlib.patches.Patch(label=access.title() + " Bandwidth", **params))

        params = dict(
            linewidth=2,
            marker='o',
            markersize=8,
            color="C{:d}".format(aidx + 3),
        )
        ax2.plot(
            xvals,
            cv['bw(mib/s)'].values,
            **params
        )
        legend_handles.append(matplotlib.lines.Line2D((0, 0), (1, 1), label=access.title() + " CV", **params))

    ax2.set_ylim(0, 0.59)
    ax2.yaxis.set_major_locator(matplotlib.ticker.MultipleLocator(0.20))
    ax2.yaxis.set_minor_locator(matplotlib.ticker.MultipleLocator(0.05))
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(xvals))
    ax.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(plot_df.index.astype(int)))
    ax.legend(
        handles=legend_handles,
        bbox_to_anchor=(0.0, 1.02, 1.0, .102),
        loc='lower left',
        ncol=2,
        mode="expand",
        borderaxespad=0.0,
        fontsize="smaller")
    ax.yaxis.grid(True)
    ax.set_axisbelow(True)
    ax.set_ylabel("Bandwidth (GiB/s)")
    ax.set_xlabel("Num Processes")
    ax.yaxis.set_minor_locator(matplotlib.ticker.MultipleLocator(base=2.5))
    ax.yaxis.grid(True, which='minor', linestyle=":")

    return ax

def plot_bw_vs_xfersize_extremes(dataset):
    COMPARE_SCALING = [
        {'nodes': dataset['nodes'].min(), 'ppn': dataset['ppn'].min()},
        {'nodes': dataset['nodes'].max(), "ppn": dataset['ppn'].max()},
        {'nodes': dataset['nodes'].min(), 'ppn': dataset['ppn'].max()},
        {'nodes': dataset['nodes'].max(), "ppn": dataset['ppn'].min()},
    ]
    LABEL_KEYS = {
        "nodes": "client",
        "ppn": "PPN",
    }
    fig, axes = matplotlib.pyplot.subplots(2, 2, figsize=(7, 5), sharex=True, sharey=True)
    fig.subplots_adjust(hspace=0, wspace=0)

    iteraxes = iter(axes.flatten())
    for constraint in COMPARE_SCALING:
        ax = next(iteraxes)
        perf = dataset
        title = []
        for param, val in constraint.items():
            perf = perf[perf[param] == val]
        ax.text(
            0.01, 0.99,
#             "{:d} client{}, {:d} PPN".format(
#                 constraint.get('nodes', -1),
#                 "s" if constraint.get('nodes', 0) != 1 else "",
#                 constraint.get('ppn', -1)),
            "$N$={:d}, $p$={:d}".format(constraint.get('nodes', -1), constraint.get('ppn', -1)),
            va='top', ha='left',
            transform=ax.transAxes)

        for aidx, access in enumerate(['write', 'read']):
            by_access = perf.groupby('access').get_group(access)
            mean_bw = by_access.groupby('xfersize').mean()['bw(mib/s)'] / 1024.0
            std_bw = by_access.groupby('xfersize').std()['bw(mib/s)'] / 1024.0

            xlabels = mean_bw.index
            xvals = numpy.arange(xlabels.shape[0])
            ax.bar(
                x=xvals - 0.45 * aidx,
                height=mean_bw.values,
                width=0.45,
                align='edge',
            )
            ax.errorbar(
                xvals - (0.225 if aidx else -0.225),
                mean_bw.values,
                yerr=std_bw.values,
                linestyle="none",
                marker=None,
                linewidth=1,
                capsize=8,
                label=access,
                color='#333333')
        ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(xvals))
        ax.xaxis.set_major_formatter(matplotlib.ticker.FuncFormatter(lambda x, pos: "{:.0f}{:1.1s}".format(*humanize_bytes(xlabels[x]))))
        for tick in ax.get_xticklabels():
            tick.set_rotation(30)
#             tick.set_ha('right')
        ax.yaxis.set_minor_locator(matplotlib.ticker.MultipleLocator(base=2.5))
        ax.yaxis.grid(True, which='minor', linestyle=":")
        ax.yaxis.grid(True, which='major')
        ax.set_axisbelow(True)
    ax.text(0.5, 0, "I/O Size", transform=fig.transFigure, va='top')
    ax.text(0.03, 0.5, "Bandwidth (GiB/s)", transform=fig.transFigure, ha='left', va='center', rotation=90)
    return axes

def plot_generic_perf_dist(datasets, dataset_name, nodes, ppns, xfersizes, x_key, y_key, scatter):
    """Generic plotter IOR sweep datasets
    
    Plots various slices of an IOR sweep dataset.  Can also synthesize some new
    columns and do basic unit conversions to, e.g., plot ``bw(gib/s)`` or
    ``stonewall_tb_moved``.
    
    Args:
        datasets (dict): Keys are names, values are DataFrames containing
            the full dataset from load_ior_output_files
        dataset_name (str): The key corresponding to ``dataset`` to plot
        nodes (list): List of node counts to include in plot.  If empty, plot all nodes.
        ppns (list): List of all PPN values to include in plot.  If empty, plot all PPNs.
        xfersizes (list): List of all xfersize values to include in plot.  If empty, plot all xfersizes.
        x_key (str): Column from datasets[dataset_name] to use for x values
        y_key (str): Column from datasets[dataset_name] to use for y values
        scatter (bool): Plot raw data points on top of means+errorbars

    Returns:
        matplotlib.Axes
    """
    VALID_NODES = set()
    VALID_PPN = set()
    VALID_XFERSIZES = set()
    for dataset in datasets.values():
        VALID_NODES |= set(dataset['nodes'].unique())
        VALID_PPN |= set(dataset['ppn'].unique())
        VALID_XFERSIZES |= set(dataset['xfersize'].unique())

    frame = datasets[dataset_name].copy()
    
    req_key = y_key
    if req_key.endswith("/node") and req_key not in frame:
        y_key = y_key[:-5]
    frame['stonewall_mib_moved'] = frame['stonewall_bytes_moved'] / 2**20

    if "gib" in y_key:
        frame[y_key] = frame[y_key.replace('gib', 'mib')] / 1024
    elif "tib" in y_key:
        frame[y_key] = frame[y_key.replace('tib', 'mib')] / 2**20
    elif "mb" in y_key:
        frame[y_key] = frame[y_key.replace('mb', 'mib')] * 2**20 / 10**6
    elif "gb" in y_key:
        frame[y_key] = frame[y_key.replace('gb', 'mib')] * 2**20 / 10**9
    elif "tb" in y_key:
        frame[y_key] = frame[y_key.replace('tb', 'mib')] * 2**20 / 10**12
    elif "kiops" in y_key:
        frame[y_key] = frame[y_key.replace("kiops", "iops")] / 1000
    elif "miops" in y_key:
        frame[y_key] = frame[y_key.replace("miops", "iops")] / 1000000

    if req_key != y_key:
        frame[req_key] = frame[y_key] / frame['nodes']

    y_key = req_key
    
    ymax = frame[y_key].max()

    init_val = not bool(nodes)
    node_filt = pandas.Series([init_val] * frame.shape[0])
    
    init_val = not bool(ppns)
    ppn_filt = pandas.Series([init_val] * frame.shape[0])
    
    init_val = not bool(xfersizes)
    xfersize_filt = pandas.Series([init_val] * frame.shape[0])
    
    for target_node in nodes:
        node_filt |= frame['nodes'] == target_node
    for target_ppn in ppns:
        ppn_filt |= frame['ppn'] == target_ppn
    for target_xfersize in xfersizes:
        xfersize_filt |= frame['xfersize'] == target_xfersize

    fig, ax = matplotlib.pyplot.subplots()

    grouped_frame = frame[node_filt & ppn_filt & xfersize_filt].groupby('access')
    for access, subframe in grouped_frame:
        yval = subframe.groupby(x_key)
        yerr = yval.std()[y_key]
        yval = yval.mean()[y_key]
        xval = yval.index
        ax.errorbar(
            x=xval,
            y=yval,
            yerr=yerr,
            capsize=4,
            label=access,
            marker='.' if not scatter else None)
        if scatter:
            ax.scatter(
                x=subframe[x_key].values,
                y=subframe[y_key].values,
            marker='.',
            alpha=0.25 if subframe.shape[0] > 100 else 1.0)
    ax.set_xscale("log", base=2)
    ax.set_xlabel(x_key)
    ax.set_ylabel(y_key)
    title = dataset_name + " "
    if not nodes or len(nodes) == len(VALID_NODES):
        title += "\nnodes=all "
    else:
        title += "\nnodes=" + "|".join([str(x) for x in nodes]) + " "
    if not ppns or len(ppns) == len(VALID_PPN):
        title += "\nppn=all "
    else:
        title += "\nppn=" + "|".join([str(x) for x in ppns]) + " "
    if not xfersizes or len(xfersizes) == len(VALID_XFERSIZES):
        title += "\nxsize=all "
    else:
        title += "\nxsize=" + "|".join(["{:.0f}{:1.1s}".format(*humanize_bytes(x)) for x in xfersizes])
    ax.set_title(title)
    ax.legend()
    ax.grid()
    
    ax.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(sorted(datasets[dataset_name][x_key].unique())))
    if x_key == "xfersize":
        ax.xaxis.set_major_formatter(matplotlib.ticker.FuncFormatter(lambda x, pos: "{:.0f}{:1.1s}".format(*humanize_bytes(x))))
    else:
        ax.xaxis.set_major_formatter(matplotlib.ticker.FormatStrFormatter("%.0f"))
    if x_key in ["xfersize", "nproc"]:
        for tick in ax.get_xticklabels():
            tick.set_rotation(90)

    ax.set_ylim(0, ymax)

    return ax